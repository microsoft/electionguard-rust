use std::{collections::HashSet, rc::Rc};

use num_bigint::BigUint;
use serde::{Deserialize, Serialize};
use util::{csprng::Csprng, z_mul_prime::ZMulPrime};

use crate::{
    ballot::BallotConfig, ballot_encrypting_tool::BallotEncryptingTool, contest::ContestOption,
    fixed_parameters::FixedParameters, key::Ciphertext, nizk::ProofRange, nonce::Nonce,
};

/// A plaintext vote for an option in a contest.
pub type ContestSelectionPlaintext = u8;

/// An encrypted option in a contest.
#[derive(Debug, Clone)]
pub struct ContestSelectionCiphertext {
    /// Ciphertext
    pub ciphertext: Ciphertext,

    /// Nonce used to produce the ciphertext
    pub nonce: BigUint,
}

/// A contest option in a pre-encrypted ballot.
#[derive(Debug, Serialize, Deserialize)]
pub struct ContestSelectionPreEncrypted {
    /// Label
    pub label: String,

    /// Vector of ciphertexts used to represent the selection
    pub selections: Vec<ContestSelectionCiphertext>,

    /// Shortcode for this option generated by hash trimming
    pub shortcode: String,

    /// Selection hash
    pub crypto_hash: String,
}

/// A contest option in a pre-encrypted ballot.
#[derive(Debug, Serialize)]
pub struct ContestSelectionEncrypted {
    /// Vector of ciphertexts used to represent the selection
    pub vote: Vec<ContestSelectionCiphertext>,

    /// Selection hash
    pub crypto_hash: String,
}

/// A contest selection by a voter.
#[derive(Debug, Serialize)]
pub struct ContestSelection {
    /// Vector used to represent the selection
    pub vote: Vec<ContestSelectionPlaintext>,
}

impl ContestSelection {
    pub fn new_pick_random(
        csprng: &mut Csprng,
        selection_limit: usize,
        num_options: usize,
    ) -> Self {
        let mut vote = HashSet::new();
        // TODO: Allow 0 selections
        let selection_limit = 1 + (csprng.next_u64() as usize % selection_limit);

        while vote.len() < selection_limit {
            vote.insert((csprng.next_u64() as usize % num_options) as u8);
        }

        Self {
            vote: vote.into_iter().collect(),
        }
    }
}

impl ContestSelectionPreEncrypted {
    pub fn get_label(&self) -> &String {
        &self.label
    }

    pub fn get_selections(&self) -> &Vec<ContestSelectionCiphertext> {
        &self.selections
    }

    pub fn get_crypto_hash(&self) -> &String {
        &self.crypto_hash
    }

    pub fn regenerate_nonces(
        &mut self,
        config: &BallotConfig,
        fixed_parameters: &FixedParameters,
        primary_nonce: &[u8],
        contest_label: &String,
        selection_labels: &Vec<String>,
        j: usize,
    ) {
        for k in 0..self.selections.len() {
            self.selections[k].nonce = Nonce::pre_encrypted(
                config,
                primary_nonce,
                contest_label.as_bytes(),
                selection_labels[j].as_bytes(),
                selection_labels[k].as_bytes(),
                fixed_parameters,
            );
        }
    }

    pub fn new(
        config: &BallotConfig,
        primary_nonce: &[u8],
        selection: &ContestOption,
        contest_label: &String,
        selection_labels: &Vec<String>,
        j: usize,
        length: usize,
        fixed_parameters: &FixedParameters,
    ) -> ContestSelectionPreEncrypted {
        let label = selection.label.clone();
        let selections = (0..length)
            .map(|k| {
                let ciphertext: Ciphertext;
                let nonce = Nonce::pre_encrypted(
                    config,
                    primary_nonce,
                    contest_label.as_bytes(),
                    selection_labels[j].as_bytes(),
                    selection_labels[k].as_bytes(),
                    fixed_parameters,
                );
                ciphertext = config.election_public_key.encrypt_with(
                    fixed_parameters,
                    &nonce,
                    (j == k) as usize,
                );
                ContestSelectionCiphertext { ciphertext, nonce }
            })
            .collect::<Vec<ContestSelectionCiphertext>>();

        let crypto_hash =
            BallotEncryptingTool::generate_selection_hash(config, selections.as_ref());
        let shortcode = BallotEncryptingTool::generate_short_code(&crypto_hash);

        // Generate pre-encrypted votes for each possible (single) choice
        ContestSelectionPreEncrypted {
            label,
            selections,
            shortcode,
            crypto_hash,
        }
    }

    pub fn proof_ballot_correctness(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &BallotConfig,
        sequence_order: usize,
        zmulq: Rc<ZMulPrime>,
    ) -> Vec<ProofRange> {
        let mut proofs = <Vec<ProofRange>>::new();
        for (i, selection) in self.selections.iter().enumerate() {
            proofs.push(selection.proof_ballot_correctness(
                csprng,
                fixed_parameters,
                config,
                sequence_order == i,
                zmulq.clone(),
            ));
        }
        proofs
    }
}

impl ContestSelectionCiphertext {
    pub fn get_nonce(&self) -> &BigUint {
        &self.nonce
    }

    pub fn set_nonce(&mut self, nonce: BigUint) {
        self.nonce = nonce;
    }

    pub fn proof_ballot_correctness(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &BallotConfig,
        selected: bool,
        zmulq: Rc<ZMulPrime>,
    ) -> ProofRange {
        ProofRange::new(
            csprng,
            fixed_parameters,
            config,
            zmulq,
            &self.nonce,
            &self.ciphertext,
            selected as usize,
            1,
        )
    }
}

/// Serialize for CiphertextContestSelection
impl Serialize for ContestSelectionCiphertext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.ciphertext.clone().serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for ContestSelectionCiphertext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        match Ciphertext::deserialize(deserializer) {
            Ok(ciphertext) => Ok(ContestSelectionCiphertext {
                ciphertext,
                nonce: BigUint::from(0 as u8),
            }),
            Err(e) => Err(e),
        }
    }
}
