use std::{
    borrow::Borrow,
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
    rc::Rc,
    time::{SystemTime, UNIX_EPOCH},
};

use anyhow::bail;
use num_bigint::{BigInt, BigUint};
use num_traits::Num;
use serde::{Deserialize, Serialize};
use util::{
    csprng::Csprng,
    z_mul_prime::{ZMulPrime, ZMulPrimeElem},
};

use crate::{
    ballot_encrypting_tool::BallotEncryptingTool,
    election_manifest::{Contest, ContestOption, ElectionManifest},
    fixed_parameters::FixedParameters,
    hash::HValue,
    key::{Ciphertext, PublicKey},
    nizk::ProofRange,
};

/// A contest option in a pre-encrypted ballot.
#[derive(Debug, Serialize)]
pub struct EncryptedContestSelection {
    /// Vector of ciphertexts used to represent the selection
    pub vote: Vec<CiphertextContestSelection>,

    /// Selection hash
    pub crypto_hash: String,

    /// Proof of ballot correctness
    pub proof_ballot_correctness: ProofRange,

    // Proof of satisfying the selection limit
    pub proof_selection_limit: ProofRange,
}

/// A contest in a pre-encrypted ballot.
#[derive(Debug)]
pub struct EncryptedContest {
    /// Label
    pub label: String,

    /// Selection in this contest
    pub selection: EncryptedContestSelection,

    /// Contest hash
    pub crypto_hash: String,
}

/// An encrypted ballot.
#[derive(Debug)]
pub struct EncryptedBallot {
    /// Label
    label: String,

    /// Contests in this ballot
    contests: Vec<EncryptedContest>,

    /// Confirmation code
    crypto_hash: String,
}

/// An encrypted option in a contest.
#[derive(Debug, Clone)]
pub struct CiphertextContestSelection {
    /// Ciphertext
    pub ciphertext: Ciphertext,

    /// Nonce used to produce the ciphertext
    pub nonce: BigUint,
}

/// A contest option in a pre-encrypted ballot.
#[derive(Debug, Serialize, Deserialize)]
pub struct PreEncryptedContestSelection {
    /// Label
    pub label: String,

    /// Vector of ciphertexts used to represent the selection
    pub selections: Vec<CiphertextContestSelection>,

    /// Shortcode for this option generated by hash trimming
    pub shortcode: String,

    /// Selection hash
    pub crypto_hash: String,
}

/// A contest in a pre-encrypted ballot.
#[derive(Debug, Serialize, Deserialize)]
pub struct PreEncryptedContest {
    /// Label
    pub label: String,

    /// Selections in this contest
    pub selections: Vec<PreEncryptedContestSelection>,

    /// Contest hash
    pub crypto_hash: String,
}

/// A pre-encrypted ballot.
#[derive(Debug, Serialize, Deserialize)]
pub struct PreEncryptedBallot {
    /// Label
    pub label: String,

    /// Contests in this ballot
    pub contests: Vec<PreEncryptedContest>,

    /// Confirmation code
    pub crypto_hash: String,
}

/// Many pre-encrypted ballots.
#[derive(Debug)]
pub struct PreEncryptedBallotList {
    /// Label
    pub label: String,

    /// A list of pre-encrypted ballots
    pub ballots: Vec<PreEncryptedBallot>,

    /// Primary nonces
    pub primary_nonces: Vec<String>,
}

/// Configuration for generating pre-encrypted ballots.
pub struct PreEncryptedBallotConfig {
    /// Election manifest
    pub manifest: ElectionManifest,
    // ballot_style: BallotStyle,
    /// Election public key
    pub election_public_key: PublicKey,

    /// Whether to encrypt the nonce with the election public key
    pub encrypt_nonce: bool,

    /// Election extended base hash
    pub h_e: HValue,
}

/// Serialize for CiphertextContestSelection
impl Serialize for CiphertextContestSelection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.ciphertext.clone().serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for CiphertextContestSelection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        match Ciphertext::deserialize(deserializer) {
            Ok(ciphertext) => Ok(CiphertextContestSelection {
                ciphertext,
                nonce: BigUint::from(0 as u8),
            }),
            Err(e) => Err(e),
        }
    }
}

impl PreEncryptedBallotList {
    pub fn new(
        config: &PreEncryptedBallotConfig,
        fixed_parameters: &FixedParameters,
        csprng: &mut Csprng,
        path: &Path,
        num_ballots: usize,
    ) -> Self {
        // let mut ballot_list: Self;
        let mut ballots = Vec::with_capacity(num_ballots);
        let mut primary_nonces = Vec::with_capacity(num_ballots);
        let label: String;
        match SystemTime::now().duration_since(UNIX_EPOCH) {
            Ok(n) => {
                label = format!("{}", n.as_secs());
            }
            Err(_) => panic!("SystemTime before UNIX EPOCH!"),
        }
        let path = path.join(label.clone());
        fs::create_dir_all(&path).unwrap();
        let mut confirmation_codes = Vec::with_capacity(num_ballots);

        for b_idx in 0..num_ballots {
            let (ballot, primary_nonce) =
                PreEncryptedBallot::new(&config, fixed_parameters, csprng);

            println!("Primary nonce str = {}", primary_nonce);
            primary_nonces.push(primary_nonce);
            ballots.push(ballot);
            confirmation_codes.push(ballots[b_idx].get_crypto_hash().clone());
            fs::write(
                path.join(format!("ballot-{}.json", confirmation_codes[b_idx])),
                serde_json::to_string(&ballots[b_idx]).unwrap(),
            )
            .unwrap();
        }

        fs::write(
            path.join("primary-nonces.json"),
            serde_json::to_string(&vec![confirmation_codes, primary_nonces.clone()]).unwrap(),
        );

        PreEncryptedBallotList {
            label,
            ballots,
            primary_nonces,
        }
    }

    pub fn read_from_directory(path: &Path) -> Option<Self> {
        if !path.is_dir() {
            return None;
        }
        let label = path.file_name().unwrap().to_str().unwrap().to_string();

        let mut codes_to_nonces = <HashMap<String, String>>::new();
        match fs::read_to_string(path.join("primary-nonces.json")) {
            Ok(nonce_file) => {
                let (confirmation_codes, primary_nonces): (Vec<String>, Vec<String>) =
                    serde_json::from_str(&nonce_file).unwrap();

                (0..confirmation_codes.len()).for_each(|i| {
                    codes_to_nonces
                        .insert(confirmation_codes[i].clone(), primary_nonces[i].clone());
                });
            }
            Err(e) => {
                eprintln!("Error reading nonce file: {}", e);
                return None;
            }
        }

        let mut ballots = Vec::new();
        let mut primary_nonces = Vec::new();
        match fs::read_dir(path) {
            Ok(entries) => {
                for entry in entries {
                    let entry = entry.unwrap();
                    let path = entry.path();
                    if path.is_file()
                        && path
                            .file_name()
                            .unwrap()
                            .to_str()
                            .unwrap()
                            .starts_with("ballot-")
                    {
                        match PreEncryptedBallot::try_new_from_file(&path) {
                            Some(ballot) => ballots.push(ballot),
                            None => {
                                eprintln!("Error reading ballot file {:?}", path);
                                return None;
                            }
                        }
                        let crypto_hash = ballots[ballots.len() - 1].get_crypto_hash().to_string();

                        match codes_to_nonces.get(&crypto_hash) {
                            Some(nonce) => primary_nonces.push(nonce.clone()),
                            None => {
                                eprintln!("No nonce found for ballot {:?}", crypto_hash);
                                return None;
                            }
                        }
                    }
                }
            }
            Err(_) => {
                eprintln!("Error reading directory");
                return None;
            }
        }

        Some(PreEncryptedBallotList {
            label,
            ballots,
            primary_nonces,
        })
    }
}

impl PreEncryptedBallot {
    pub fn get_label(&self) -> &String {
        &self.label
    }

    pub fn get_contests(&self) -> &Vec<PreEncryptedContest> {
        &self.contests
    }

    pub fn get_crypto_hash(&self) -> &String {
        &self.crypto_hash
    }

    pub fn try_new_with(
        config: &PreEncryptedBallotConfig,
        fixed_parameters: &FixedParameters,
        primary_nonce: &[u8],
    ) -> Option<Self> {
        // TODO: Find contests in manifest corresponding to requested ballot style

        // Generate contests

        println!("Primary nonce = {:?}", primary_nonce);

        let label = "Sample Election".to_string();
        let b_aux = "Sample Aux Info".as_bytes();

        let mut success = true;
        let mut contests = Vec::new();
        for contest in &config.manifest.contests {
            match PreEncryptedContest::try_new(
                config,
                primary_nonce.as_ref(),
                &contest,
                fixed_parameters,
            ) {
                Some(c) => contests.push(c),
                None => {
                    success = false;
                    break;
                }
            }
        }

        match success {
            true => {
                let crypto_hash =
                    BallotEncryptingTool::generate_confirmation_code(config, &contests, b_aux);

                println!("Confirmation Code:\t{:?}", crypto_hash);

                Some(PreEncryptedBallot {
                    label,
                    contests,
                    crypto_hash,
                })
            }
            false => None,
        }
    }

    pub fn new(
        config: &PreEncryptedBallotConfig,
        fixed_parameters: &FixedParameters,
        csprng: &mut Csprng,
    ) -> (PreEncryptedBallot, String) {
        loop {
            // Generate primary nonce
            let mut primary_nonce = [0u8; 32];
            (0..32).for_each(|i| primary_nonce[i] = csprng.next_u8());

            println!("Primary nonce = {:?}", primary_nonce);
            match PreEncryptedBallot::try_new_with(config, fixed_parameters, &primary_nonce) {
                Some(ballot) => return (ballot, HValue(primary_nonce).to_string()),
                None => continue,
            }
        }
    }

    pub fn nizkp(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &PreEncryptedBallotConfig,
        voter_selections: &Vec<Vec<usize>>,
    ) -> (Vec<Vec<Vec<ProofRange>>>, Vec<ProofRange>) {
        assert!(voter_selections.len() == self.contests.len());

        // let zmulp = Rc::new(ZMulPrime::new(fixed_parameters.p.clone()));
        let zmulq = Rc::new(ZMulPrime::new(fixed_parameters.q.clone()));

        let mut proof_ballot_correctness = <Vec<Vec<Vec<ProofRange>>>>::new();
        let mut proof_selection_limit = <Vec<ProofRange>>::new();
        for (i, contest) in self.contests.iter().enumerate() {
            proof_ballot_correctness.push(contest.proof_ballot_correctness(
                csprng,
                fixed_parameters,
                config,
                zmulq.clone(),
            ));
            proof_selection_limit.push(contest.proof_selection_limit(
                csprng,
                fixed_parameters,
                config,
                zmulq.clone(),
                config.manifest.contests[i].selection_limit,
                voter_selections[i].as_slice(),
            ));
        }

        (proof_ballot_correctness, proof_selection_limit)
    }

    pub fn try_new_from_file(path: &PathBuf) -> Option<Self> {
        match fs::read_to_string(path) {
            Ok(contents) => match serde_json::from_str(&contents) {
                Ok(ballot) => Some(ballot),
                Err(e) => {
                    println!("Error: {:?}", e);
                    None
                }
            },
            Err(e) => {
                println!("Error: {:?}", e);
                None
            }
        }
    }
}

impl PreEncryptedContest {
    pub fn get_label(&self) -> &String {
        &self.label
    }

    pub fn get_selections(&self) -> &Vec<PreEncryptedContestSelection> {
        &self.selections
    }

    pub fn get_crypto_hash(&self) -> &String {
        &self.crypto_hash
    }

    pub fn regenerate_nonces(
        &mut self,
        config: &PreEncryptedBallotConfig,
        fixed_parameters: &FixedParameters,
        primary_nonce: &[u8],
        selection_labels: &Vec<String>,
    ) {
        for j in 0..self.selections.len() {
            self.selections[j].regenerate_nonces(
                config,
                fixed_parameters,
                primary_nonce,
                &self.label,
                &selection_labels,
                j,
            );
        }
    }

    pub fn sanitize_contest(contest: &Contest) -> Contest {
        let mut modified_contest = contest.clone();
        eprintln!("Contest:\t{:?}", modified_contest.label);

        // TODO: Stop assuming null labels are not included
        // Add labels for null selections
        (0..modified_contest.selection_limit).for_each(|j| {
            modified_contest.options.push(ContestOption {
                label: format!("null{}", j + 1),
            })
        });

        modified_contest
    }

    pub fn try_new(
        config: &PreEncryptedBallotConfig,
        primary_nonce: &[u8],
        contest: &Contest,
        fixed_parameters: &FixedParameters,
    ) -> Option<PreEncryptedContest> {
        let contest = PreEncryptedContest::sanitize_contest(contest);

        let mut success = true;
        let mut selections = <Vec<PreEncryptedContestSelection>>::new();
        let selection_labels = contest
            .options
            .iter()
            .map(|o| o.label.clone())
            .collect::<Vec<String>>();
        for j in 0..contest.options.len() {
            let selection = PreEncryptedContestSelection::new(
                config,
                primary_nonce,
                &contest.options[j],
                contest.label.borrow(),
                selection_labels.borrow(),
                j,
                selection_labels.len(),
                fixed_parameters,
            );
            success &= BallotEncryptingTool::check_shortcode(&selections, &selection);
            if success {
                selections.push(selection);
            }
        }

        // generate_selection also generates encrypted null selections

        match success {
            true => {
                let crypto_hash = BallotEncryptingTool::generate_contest_hash(
                    config,
                    &contest.label,
                    &selections,
                );

                eprintln!("Contest Hash:\t{:?}", crypto_hash);

                Some(PreEncryptedContest {
                    label: contest.label,
                    selections,
                    crypto_hash,
                })
            }
            false => None,
        }
    }

    pub fn proof_ballot_correctness(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &PreEncryptedBallotConfig,
        zmulq: Rc<ZMulPrime>,
    ) -> Vec<Vec<ProofRange>> {
        // assert!(voter_selections.len() <= self.selections.len());

        let mut proofs = <Vec<Vec<ProofRange>>>::new();
        for (i, selection) in self.selections.iter().enumerate() {
            proofs.push(selection.proof_ballot_correctness(
                csprng,
                fixed_parameters,
                config,
                i,
                zmulq.clone(),
            ));
        }
        proofs
    }

    pub fn proof_selection_limit(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &PreEncryptedBallotConfig,
        zmulq: Rc<ZMulPrime>,
        selection_limit: usize,
        voter_selections: &[usize],
    ) -> ProofRange {
        let combined_selection = Self::sum_selection_vector(
            fixed_parameters,
            &self.combine_voter_selections(fixed_parameters, voter_selections),
        );

        ProofRange::new(
            csprng,
            fixed_parameters,
            config,
            zmulq,
            &combined_selection.nonce,
            &combined_selection.ciphertext,
            voter_selections.len(),
            selection_limit,
        )
    }

    pub fn combine_voter_selections(
        &self,
        fixed_parameters: &FixedParameters,
        voter_selections: &[usize],
    ) -> Vec<CiphertextContestSelection> {
        assert!(0 < voter_selections.len() && voter_selections.len() <= self.selections.len());

        let mut selections = <Vec<&Vec<CiphertextContestSelection>>>::new();
        for idx in voter_selections {
            selections.push(&self.selections[*idx].selections);
        }

        let mut combined_selection = selections[0].clone();

        for i in (1..voter_selections.len()) {
            for j in (0..combined_selection.len()) {
                combined_selection[j].ciphertext.alpha = (&combined_selection[j].ciphertext.alpha
                    * &selections[i][j].ciphertext.alpha)
                    % fixed_parameters.p.as_ref();
                combined_selection[j].ciphertext.beta = (&combined_selection[j].ciphertext.beta
                    * &selections[i][j].ciphertext.beta)
                    % fixed_parameters.p.as_ref();
                combined_selection[j].nonce = (&combined_selection[j].nonce
                    + &selections[i][j].nonce)
                    % fixed_parameters.q.as_ref();
            }
        }
        combined_selection
    }

    pub fn sum_selection_vector(
        fixed_parameters: &FixedParameters,
        selection: &Vec<CiphertextContestSelection>,
    ) -> CiphertextContestSelection {
        let mut sum_ct = selection[0].ciphertext.clone();
        let mut sum_nonce = selection[0].nonce.clone();
        for i in 1..selection.len() {
            sum_ct.alpha =
                (&sum_ct.alpha * &selection[i].ciphertext.alpha) % fixed_parameters.p.as_ref();
            sum_ct.beta =
                (&sum_ct.beta * &selection[i].ciphertext.beta) % fixed_parameters.p.as_ref();
            sum_nonce = (&sum_nonce + &selection[i].nonce) % fixed_parameters.q.as_ref();
        }

        CiphertextContestSelection {
            ciphertext: sum_ct,
            nonce: sum_nonce,
        }
    }
}

impl PreEncryptedContestSelection {
    pub fn get_label(&self) -> &String {
        &self.label
    }

    pub fn get_selections(&self) -> &Vec<CiphertextContestSelection> {
        &self.selections
    }

    pub fn get_crypto_hash(&self) -> &String {
        &self.crypto_hash
    }

    pub fn regenerate_nonces(
        &mut self,
        config: &PreEncryptedBallotConfig,
        fixed_parameters: &FixedParameters,
        primary_nonce: &[u8],
        contest_label: &String,
        selection_labels: &Vec<String>,
        j: usize,
    ) {
        for k in 0..self.selections.len() {
            self.selections[k].nonce = BallotEncryptingTool::generate_nonce(
                config,
                primary_nonce,
                contest_label.as_bytes(),
                selection_labels[j].as_bytes(),
                selection_labels[k].as_bytes(),
                fixed_parameters,
            );
        }
    }

    pub fn new(
        config: &PreEncryptedBallotConfig,
        primary_nonce: &[u8],
        selection: &ContestOption,
        contest_label: &String,
        selection_labels: &Vec<String>,
        j: usize,
        length: usize,
        fixed_parameters: &FixedParameters,
    ) -> PreEncryptedContestSelection {
        let label = selection.label.clone();
        let selections = (0..length)
            .map(|k| {
                let ciphertext: Ciphertext;
                let nonce = BallotEncryptingTool::generate_nonce(
                    config,
                    primary_nonce,
                    contest_label.as_bytes(),
                    selection_labels[j].as_bytes(),
                    selection_labels[k].as_bytes(),
                    fixed_parameters,
                );
                ciphertext = config.election_public_key.encrypt_with(
                    fixed_parameters,
                    &nonce,
                    (j == k) as usize,
                );
                CiphertextContestSelection { ciphertext, nonce }
            })
            .collect::<Vec<CiphertextContestSelection>>();

        let crypto_hash =
            BallotEncryptingTool::generate_selection_hash(config, selections.as_ref());
        let shortcode = BallotEncryptingTool::generate_short_code(&crypto_hash);

        eprintln!(
            "Selection Hash for {}:\t{} / Shortcode: {}",
            selection.label, crypto_hash, shortcode
        );

        // Generate pre-encrypted votes for each possible (single) choice
        PreEncryptedContestSelection {
            label,
            selections,
            shortcode,
            crypto_hash,
        }
    }

    pub fn proof_ballot_correctness(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &PreEncryptedBallotConfig,
        sequence_order: usize,
        zmulq: Rc<ZMulPrime>,
    ) -> Vec<ProofRange> {
        let mut proofs = <Vec<ProofRange>>::new();
        for (i, selection) in self.selections.iter().enumerate() {
            proofs.push(selection.proof_ballot_correctness(
                csprng,
                fixed_parameters,
                config,
                sequence_order == i,
                zmulq.clone(),
            ));
        }
        proofs
    }
}

impl CiphertextContestSelection {
    pub fn get_nonce(&self) -> &BigUint {
        &self.nonce
    }

    pub fn set_nonce(&mut self, nonce: BigUint) {
        self.nonce = nonce;
    }

    pub fn proof_ballot_correctness(
        &self,
        csprng: &mut Csprng,
        fixed_parameters: &FixedParameters,
        config: &PreEncryptedBallotConfig,
        selected: bool,
        zmulq: Rc<ZMulPrime>,
    ) -> ProofRange {
        ProofRange::new(
            csprng,
            fixed_parameters,
            config,
            zmulq,
            &self.nonce,
            &self.ciphertext,
            selected as usize,
            1,
        )
    }
}
